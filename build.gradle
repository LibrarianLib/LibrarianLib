buildscript {
    repositories {
        maven { url = 'https://files.minecraftforge.net/maven' }
        maven { url = 'http://repo.spongepowered.org/maven' }
        jcenter()
        mavenCentral()
        gradlePluginPortal()
    }
    dependencies {
        classpath group: 'net.minecraftforge.gradle', name: 'ForgeGradle', version: '3.+', changing: true
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:1.3.61"
        classpath 'org.spongepowered:mixingradle:0.7-SNAPSHOT'
        // rolled back from 4.0.4 to 4.0.1 due to #425: https://github.com/johnrengelman/shadow/issues/425
        classpath 'com.github.jengelman.gradle.plugins:shadow:4.0.1'
    }
}

// this is populated by the modules, since the modules need to know about each other's relocation packages
ext.shadePackages = new HashSet<String>()

allprojects {
    apply plugin: 'eclipse'
    apply plugin: 'idea'
    apply plugin: 'kotlin'
    apply plugin: 'java-library'

    ext.allmodules = rootProject.subprojects.findAll { it.path != ":runtime" }

    // unfortunately, due to the interdependence of the modules, all the repositories used must be specified here. Any
    // repositories defined in the module `build.gradle` files won't be seen by any of the other modules
    repositories {
        mavenLocal()
        jcenter()
        maven { url = "http://maven.shadowfacts.net/" }
        maven { url = "https://jitpack.io" }
        maven { url = "https://minecraft.curseforge.com/api/maven/" }
        maven { url = 'http://repo.spongepowered.org/maven' }
    }
}

version = mod_version
group = "com.teamwizardry.librarianlib"
archivesBaseName = "librarianlib"

sourceCompatibility = targetCompatibility = compileJava.sourceCompatibility = compileJava.targetCompatibility = '1.8' // Need this here so eclipse task generates correctly.

task setupShadowJars {
    group = 'librarianlib'
}

configure(allmodules) {
    apply from: "$rootDir/gradle/module.gradle"
}

// =====================================================================================================================
// Build setup
// =====================================================================================================================

ext.productionModules = allmodules.findAll { it.name != "testbase" }

configurations {
    runtime.extendsFrom(mod)
}

//region Merged file generation

// Generated files:
// - MixinConnector.java
//   - generated by merging all the `META-INF/mixins.txt` files
// - META-INF/coremods.json
//   - generated by merging from all the `META-INF/coremods.json` files
// - META-INF/mods.toml
//   - generated by appending all the `META-INF/dependencies.toml` files to the core `META-INF/mods.toml` file
// - pack.mcmeta
//   - copied from the core module (I copy it here so I can do a blanket exclude later)
task generateFiles(type: Sync) {
    group = 'librarianlib'
    ext.genDir = "$buildDir/generated"
    def coreResources = project(":core").rootDir.path + '/src/main/resources'
    ext.coreModsToml = file("$coreResources/META-INF/mods.toml")
    ext.corePackMcmeta = file("$coreResources/pack.mcmeta")

    ext.allCoremods = productionModules.collect { file("${it.rootDir}/src/main/resources/META-INF/coremods.json") }
    ext.allDependencies = productionModules.collect { file("${it.rootDir}/src/main/resources/META-INF/dependencies.toml") }
    ext.allMixins = productionModules.collect { file("${it.rootDir}/src/main/resources/META-INF/mixins.txt") }

    inputs.files(
            coreModsToml,
            corePackMcmeta,
            allCoremods,
            allDependencies,
            allMixins
    )

    ext.mixinConnectorOut = file("$genDir/com/teamwizardry/librarianlib/MixinConnector.java")
    ext.coremodsOut = file("$genDir/META-INF/coremods.json")
    ext.modsTomlOut = file("$genDir/META-INF/mods.toml")
    ext.packMcmetaOut = file("$genDir/pack.mcmeta")
    outputs.files(
            mixinConnectorOut,
            coremodsOut,
            packMcmetaOut
    )
    if(project.name != "core")
        outputs.files(modsTomlOut)

    doLast {
        mixinConnectorOut.parentFile.mkdirs()
        coremodsOut.parentFile.mkdirs()

        def allMixinConfigs = allMixins.filter { it.exists() }.collect { it.readLines() }.flatten()
        mixinConnectorOut.text = """\
               |package com.teamwizardry.librarianlib;

               |import org.spongepowered.asm.mixin.Mixins;
               |import org.spongepowered.asm.mixin.connect.IMixinConnector;

               |public class MixinConnector implements IMixinConnector {
               |    @Override
               |    public void connect() {
               |        ${allMixinConfigs.collect { "Mixins.addConfiguration(\"$it\");" }.join("\n|        ")}
               |    }
               |}
            """.stripMargin()

        // merge the coremods.json files
        coremodsOut.text =
                "{\n" + allCoremods.filter { it.exists() }.collect {
                    it.text
                            .replaceAll("[{}]", "") // replace enclosing brackets with blank lines
                            .replaceAll("\\s+\$", "") // remove trailing whitespace
                            .split("\n").findAll { !it.matches("^\\s*\$") } // remove blank lines
                            .join("\n") // re-join lines
                }.join(",\n") + "\n}"

        // copy the pack.mcmeta file
        packMcmetaOut.text = corePackMcmeta.text

        if(project.name != "core")
        // add additional external dependencies to main mods.toml
            modsTomlOut.text = coreModsToml.text + allDependencies
                    .filter { it.exists() }
                    .collect {
                        it.text
                                .replaceAll("MOD_ID", "librarianlib")
                                .replaceAll("\\s+\$", "")
                    }.join("\n")
    }
}
sourceSets.main.allSource.srcDir(generateFiles.genDir)
compileJava.dependsOn(generateFiles)

CopySpec createMergeSpec(String jarTaskName) {
    return copySpec {
        duplicatesStrategy = 'INCLUDE'
        productionModules.each {
//        from(file("${mod.compileJava.temporaryDir}/${mod.sourceSets.main.refMap}"))
            from(zipTree(it.tasks.getByName(jarTaskName).outputs.files.singleFile)) {
                exclude '**/SkeletonMod.*'
                exclude '**/MixinConnector.*'
                exclude 'META-INF/coremods.json'
                exclude 'META-INF/mods.toml'
                exclude 'META-INF/dependencies.toml'
                exclude 'META-INF/mixins.txt'
                exclude 'META-INF/mods.toml'
                exclude 'pack.mcmeta'
                // the core module generates an `index.txt` that stores a list of modules to load at runtime. This list
                // includes the dev-only testbase module, so we have to strip that out first
                filesMatching('META-INF/modules/index.txt') {
                    filter { it == "testbase" ? null : it }
                }
            }
        }
    }
}
//endregion

//region Merged jar configurations

def attributes = [
        "Implementation-Title"    : "LibrarianLib",
        "Implementation-Version"  : "$mod_version",
        "Implementation-Vendor"   : "Team Wizardry",
        "Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
        // Specify the IMixinConnector. This class is present at runtime, but the runtime manifest
        // specifies a different mixin container with only the mixin files from that specific module.
        // https://github.com/SpongePowered/Mixin/wiki/Release-Notes---Mixin-0.8#toolchain-and-environment-changes
        "MixinConnector"          : "com.teamwizardry.librarianlib.MixinConnector"
]

jar {
    enabled = false
}

task obfJar(type: Jar) {
    group = 'build'
    classifier = ''
    manifest.attributes(attributes)
    includeEmptyDirs = false
    duplicatesStrategy = 'WARN'

    from sourceSets.main.output
    afterEvaluate {
        productionModules.each {
            dependsOn it.obfJar
        }
        with createMergeSpec('obfJar')
    }
}

task deobfJar(type: Jar) {
    group = 'build'
    classifier = 'deobf'
    manifest.attributes(attributes)
    includeEmptyDirs = false
    duplicatesStrategy = 'WARN'

    from sourceSets.main.output
    afterEvaluate {
        productionModules.each {
            dependsOn it.deobfJar
        }
        with createMergeSpec('deobfJar')
    }
}

task sourcesJar(type: Jar) {
    group = 'build'
    classifier = 'sources'
    manifest.attributes(attributes)
    includeEmptyDirs = false
    duplicatesStrategy = 'WARN'

    from sourceSets.main.allSource
    afterEvaluate {
        productionModules.each {
            dependsOn it.sourcesJar
        }
        with createMergeSpec('sourcesJar')
    }

    exclude '**/*.class'
}
assemble.dependsOn obfJar, deobfJar, sourcesJar

//endregion

//region Shared publish configuration

configure(productionModules + [project]) {
    components.java

    artifacts {
        archives obfJar, deobfJar, sourcesJar
    }

    // For some reason we need to apply the publish plugin at the last moment, otherwise there are odd issues with it
    // already being configured
    apply plugin: 'maven-publish'
    publishing {
        publications {
            mod(MavenPublication) {
                from components.java
                artifacts = [obfJar, deobfJar, sourcesJar]
                pom {
                    // `.toString()` immediately evaluates the `GString` to a `String`, which is apparently necessary
                    // for the maven-publish plugin
                    name = project == rootProject ? "LibrarianLib" : "LibrarianLib $human_name".toString()
                    description = project == rootProject ? "The final packaged LibrarianLib jar" : "$module_description".toString()
                    url = 'http://github.com/LibrarianLib/LibrarianLib'
                    licenses {
                        license {
                            name = 'GNU Lesser General Public License v3'
                            url = 'https://www.gnu.org/licenses/lgpl-3.0.txt'
                        }
                    }
                    scm {
                        connection = 'scm:git:https://github.com/LibrarianLib/LibrarianLib.git'
                        developerConnection = 'scm:git:ssh://github.com/LibrarianLib/LibrarianLib.git'
                        url = 'https://github.com/LibrarianLib/LibrarianLib'
                    }
                    // Remove the forge dependencies from the POM
                    withXml {
                        def node = asNode()
                        def excludes = ['net.minecraftforge', 'll']
                        node.dependencies.'*'.findAll {
                            excludes.contains(it.groupId.text())
                        }.each {
                            it.parent().remove(it)
                        }
                    }
                }
            }
        }
        repositories {
            maven {
                // change URLs to point to your repos, e.g. http://my.org/repo
                def releasesRepoUrl = "file://$buildDir/repos/releases"
                def snapshotsRepoUrl = "file://$buildDir/repos/snapshots"
                url = version.endsWith('SNAPSHOT') ? snapshotsRepoUrl : releasesRepoUrl
            }
        }
    }
}
//endregion
