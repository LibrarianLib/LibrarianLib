buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        // rolled back from 4.0.4 to 4.0.1 due to #425: https://github.com/johnrengelman/shadow/issues/425
        classpath 'com.github.jengelman.gradle.plugins:shadow:4.0.1'
    }
}

import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import com.github.jengelman.gradle.plugins.shadow.ShadowStats
import com.github.jengelman.gradle.plugins.shadow.relocation.Relocator
import com.github.jengelman.gradle.plugins.shadow.relocation.RelocatePathContext

def relocatedDependencyDir = "${rootProject.buildDir}/relocated"

configurations {
    shade
    api.extendsFrom(remapped)
    testApi.extendsFrom(remapped)
}

def moduleProject = project
def capName = project.name[0].toUpperCase() + project.name.substring(1)

// the remap tasks have to be added to the root project, otherwise MixinGradle tries to add refmaps, which makes them
// depend on the compile tasks, which means we wouldn't be able to create the shadowed jars if the build is erroring
ext.remapDependencies = rootProject.tasks.create("remap${capName}Dependencies", ShadowJar.class) {
    configurations = [moduleProject.configurations.shade]

    archiveName("shadow-${moduleProject.name}.jar")
    destinationDir(file(relocatedDependencyDir))

    afterEvaluate {
        rootProject.shadePackages.each { String pkg ->
            relocate pkg, "ll.$pkg"
        }
    }
}

ext.remapDependencySources = rootProject.tasks.create("remap${capName}DependencySources", Jar.class) {
    inputs.files(moduleProject.configurations.shade)

    archiveName("shadow-${moduleProject.name}-sources.jar")
    destinationDir(file(relocatedDependencyDir))

    afterEvaluate {

        from moduleProject.configurations.detachedConfiguration(
                moduleProject.configurations.shade.allDependencies.collect({ dep ->
                    def sourceDep = moduleProject.dependencies.create(group: dep.group,
                            name: dep.name,
                            classifier: 'sources',
                            version: dep.version)
                    // apply any exclusions from the main dependency to the sources dependency
                    if (dep instanceof ModuleDependency && sourceDep instanceof ModuleDependency) {
                        def originalModule = (ModuleDependency) dep
                        def sourceModule = (ModuleDependency) sourceDep

                        originalModule.excludeRules.each {
                            sourceModule.exclude group: it.group, module: it.module
                        }
                    }
                    return sourceDep
                }) as Dependency[]).collect { f ->
            f.directory ? fileTree(f) : zipTree(f)
        }
        def stats = new ShadowStats()
        // remap sources
        eachFile { FileCopyDetails copyDetails ->
            moduleProject.remapDependencies.relocators.each { Relocator reloc ->
                def pathContext = new RelocatePathContext(copyDetails.sourcePath, stats)
                if (reloc.canRelocatePath(pathContext)) {
                    copyDetails.path = reloc.relocatePath(pathContext)
                }
                if (!copyDetails.directory)
                    copyDetails.filter { String line ->
                        reloc.applyToSourceContent(line)
                    }
            }
        }
    }
}

task setupShadowJars {
    dependsOn moduleProject.remapDependencies, moduleProject.remapDependencySources
}

rootProject.setupShadowJars.dependsOn setupShadowJars

repositories {
    flatDir {
        dir(relocatedDependencyDir)
    }
}

dependencies {
    if(file("$relocatedDependencyDir/shadow-${project.name}.jar").exists()) {
        remapped "ll:shadow-${project.name}:0"
    }
}
