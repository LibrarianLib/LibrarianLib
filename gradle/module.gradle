buildscript {
    repositories {
        maven { url = 'https://files.minecraftforge.net/maven' }
        maven { url = 'http://repo.spongepowered.org/maven' }
        jcenter()
        mavenCentral()
        gradlePluginPortal()
    }
    dependencies {
        classpath group: 'net.minecraftforge.gradle', name: 'ForgeGradle', version: '3.+', changing: true
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:1.3.61"
        classpath 'org.spongepowered:mixingradle:0.7-SNAPSHOT'
        // rolled back from 4.0.4 to 4.0.1 due to #425: https://github.com/johnrengelman/shadow/issues/425
        classpath 'com.github.jengelman.gradle.plugins:shadow:4.0.1'
    }
}

apply plugin: 'net.minecraftforge.gradle'
apply plugin: 'org.spongepowered.mixin'
apply plugin: 'com.github.johnrengelman.shadow'

import com.github.jengelman.gradle.plugins.shadow.ShadowStats
import com.github.jengelman.gradle.plugins.shadow.relocation.RelocatePathContext
import com.github.jengelman.gradle.plugins.shadow.relocation.Relocator
import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar

ext.modid = project.name == "core" ? "librarianlib" : "librarianlib-${project.name}".toString()
ext.modid_test = "$modid-test".toString()

// Need this here so eclipse task generates correctly.
sourceCompatibility = targetCompatibility = compileJava.sourceCompatibility = compileJava.targetCompatibility = '1.8'
version = rootProject.mod_version
group = "com.teamwizardry.librarianlib"
archivesBaseName = modid

configurations {
    api.extendsFrom(mod)
    testApi.extendsFrom(mod)
}
apply from: "$rootDir/gradle/relocate.gradle"

minecraft {
    mappings channel: mc_mappings_channel, version: mc_mappings_version
}

dependencies {
    minecraft "net.minecraftforge:forge:$mc_version-$forge_version"
    implementation("org.spongepowered:mixin:0.8-SNAPSHOT")

    // Add kotlin dependencies manually to the modules, but don't include them at runtime, since Kottle doesn't include
    // kotlin sources
    compileOnly "org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.3.61"
    compileOnly "org.jetbrains.kotlin:kotlin-reflect:1.3.61"
    compileOnly "org.jetbrains:annotations:18.0.0"
    compileOnly "org.jetbrains.kotlinx:kotlinx-coroutines-jdk8:1.3.2"

    testCompileOnly "org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.3.61"
    testCompileOnly "org.jetbrains.kotlin:kotlin-reflect:1.3.61"
    testCompileOnly "org.jetbrains:annotations:18.0.0"
    testCompileOnly "org.jetbrains.kotlinx:kotlinx-coroutines-jdk8:1.3.2"

    // include Kottle _after_ all of the kotlin libraries, so IntelliJ IDEA uses the direct dependencies first
    mod files("/Users/code/Documents/mods/kottle/build/libs/Kottle-1.5.0.jar")
//    mod "kottle:Kottle:$kottle_version"

    compileOnly "kottle:Kottle:$kottle_version"
    testCompileOnly "kottle:Kottle:$kottle_version"
}

mixin {
}

tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all {
    kotlinOptions {
        jvmTarget = "1.8"
        freeCompilerArgs += [
                "-Xjvm-default=enable",
                "-Xuse-experimental=kotlin.Experimental",
                "-Xuse-experimental=kotlin.ExperimentalUnsignedTypes"
        ]
    }
}

// exclude "master" files from output
def masterPatterns = [
        "**/*.psd",
        "**/*.xcf",
        "**/*.kra",
        "**/*.blend",
        "**/_master/**"
]

processResources {
    masterPatterns.each {
        exclude it
    }
}
processTestResources {
    masterPatterns.each {
        exclude it
    }
}

// =====================================================================================================================
//region // Build setup

sourceSets {
    main {
        ext.refMap = "${project.name}.refmap.json"
    }
    test {
        ext.refMap = "${project.name}-test.refmap.json"
    }
}

// ---------------------------------------------------------------------------------------------------------------------
//region // File generation

static String tomlDependency(String modid, String dependencyid, String version, String ordering) {
    return """\
       |[[dependencies.$modid]]
       |    modId="$dependencyid"
       |    versionRange="$version"
       |    mandatory=true
       |    ordering="$ordering"
       |""".stripMargin()
}

// Generated files:
// - MixinConnector.java
//   - generated by merging all the `META-INF/mixins.txt` files
// - SkeletonMod.java
//   - generated based on the mod ID
// - META-INF/mods.toml
//   - generated by appending the `META-INF/dependencies.toml` files to a skeleton `mods.toml` file
// - pack.mcmeta
task generateFiles {
    inputs.properties mod_version: mod_version, human_name: human_name, modid: modid, description: description

    ext.genJava = "$buildDir/generated/main/java"
    ext.genResources = "$buildDir/generated/main/resources"
    ext.resourcesDir = "$projectDir/src/main/resources"

    ext.mixinsTxt = file("$resourcesDir/META-INF/mixins.txt")
    ext.manifest = file("$resourcesDir/META-INF/MANIFEST.MF")

    inputs.files(
            mixinsTxt,
            manifest
    )
    ext.mixinConnectorOut = file("$genJava/${project.name}/main/MixinConnector.java")
    ext.skeletonModOut = file("$genJava/${project.name}/main/SkeletonMod.java")
    ext.modsTomlOut = file("$genResources/META-INF/mods.toml")
    ext.manifestOut = file("$genResources/META-INF/MANIFEST.MF")
    ext.packMcmetaOut = file("$genResources/pack.mcmeta")
    outputs.files(
            mixinConnectorOut,
            skeletonModOut,
            modsTomlOut,
            manifestOut
    )
    if(project.name != "core")
        outputs.files(packMcmetaOut)

    doLast {
        modsTomlOut.parentFile.mkdirs()

        skeletonModOut.text = """\
               |package ${project.name}.main;
               |
               |import net.minecraftforge.fml.common.Mod;
               |
               |@Mod("$modid")
               |public class SkeletonMod {}
            |""".stripMargin()

        def mixinConfigs = mixinsTxt.exists() ? mixinsTxt.readLines() : []
        mixinConnectorOut.text = """\
               |package ${project.name}.main;
               |
               |import org.spongepowered.asm.mixin.Mixins;
               |import org.spongepowered.asm.mixin.connect.IMixinConnector;
               |
               |public class MixinConnector implements IMixinConnector {
               |    @Override
               |    public void connect() {
               |        ${mixinConfigs.collect { "Mixins.addConfiguration(\"$it\");" }.join("\n|        ")}
               |    }
               |}
            |""".stripMargin()

        manifestOut.text = (manifest.exists() ? manifest.text : "") + "MixinConnector: ${project.name}.main.MixinConnector\n"

        if(project.name != "core")
            packMcmetaOut.text = """\
                   |{
                   |    "pack": {
                   |        "description": "LibrarianLib $human_name resources",
                   |        "pack_format": 4
                   |    }
                   |}
                |""".stripMargin()

        def tomlString = """\
               |modLoader="kotlinfml"
               |loaderVersion="[1,)"
               |[[mods]]
               |modId="$modid"
               |version="$mod_version"
               |displayName="LibrarianLib $human_name"
               |description="$description"
        |""".stripMargin()
        if(project.name != "core")
            tomlString += """\
                   |[[dependencies.$modid]]
                   |    modId="librarianlib"
                   |    versionRange="[$mod_version]"
                   |    mandatory=true
                   |    ordering="BEFORE"
            |""".stripMargin()
        modsTomlOut.text = tomlString
    }
}
sourceSets.main.java.srcDirs(generateFiles.genJava)
sourceSets.main.resources.srcDirs(generateFiles.genResources)
compileJava.dependsOn(generateFiles)
compileKotlin.dependsOn(generateFiles)

// Generated test files:
// - MixinConnector.java
//   - generated by merging all the `META-INF/mixins.txt` files
// - SkeletonMod.java
//   - generated based on the mod ID
// - META-INF/mods.toml
//   - generated by appending the `META-INF/dependencies.toml` files to a skeleton `mods.toml` file
// - pack.mcmeta
task generateTestFiles {
    inputs.properties mod_version: mod_version, human_name: human_name, modid_test: modid_test

    ext.genJava = "$buildDir/generated/test/java"
    ext.genResources = "$buildDir/generated/test/resources"
    ext.resourcesDir = "$projectDir/src/test/resources"

    ext.mixinsTxt = file("$resourcesDir/META-INF/mixins.txt")
    ext.dependenciesToml = file("$resourcesDir/META-INF/dependencies.toml")
    ext.manifest = file("$resourcesDir/META-INF/MANIFEST.MF")

    inputs.files(
            mixinsTxt,
            dependenciesToml,
            manifest
    )

    ext.mixinConnectorOut = file("$genJava/${project.name}/test/MixinConnector.java")
    ext.modsTomlOut = file("$genResources/META-INF/mods.toml")
    ext.manifestOut = file("$genResources/META-INF/MANIFEST.MF")
    ext.packMcmetaOut = file("$genResources/pack.mcmeta")
    outputs.files(
            mixinConnectorOut,
            modsTomlOut,
            manifestOut,
            packMcmetaOut
    )

    doLast {
        modsTomlOut.parentFile.mkdirs()

        def mixinConfigs = mixinsTxt.exists() ? mixinsTxt.readLines() : []
        mixinConnectorOut.text = """\
               |package ${project.name}.test;
               |
               |import org.spongepowered.asm.mixin.Mixins;
               |import org.spongepowered.asm.mixin.connect.IMixinConnector;
               |
               |public class MixinConnector implements IMixinConnector {
               |    @Override
               |    public void connect() {
               |        ${mixinConfigs.collect { "Mixins.addConfiguration(\"$it\");" }.join("\n|        ")}
               |    }
               |}
            |""".stripMargin()

        manifestOut.text = (manifest.exists() ? manifest.text : "") + "MixinConnector: ${project.name}.test.MixinConnector\n"

        packMcmetaOut.text = """\
               |{
               |    "pack": {
               |        "description": "LibrarianLib $human_name resources",
               |        "pack_format": 4
               |    }
               |}
            |""".stripMargin()

        def tomlString = """\
               |modLoader="kotlinfml"
               |loaderVersion="[1,)"
               |[[mods]]
               |modId="$modid_test"
               |version="$mod_version"
               |displayName="LibrarianLib $human_name Test"
               |description="Tests for the $human_name module"
        |""".stripMargin()
        tomlString += """\
               |[[dependencies.$modid_test]]
               |    modId="librarianlib"
               |    versionRange="[$mod_version]"
               |    mandatory=true
               |    ordering="BEFORE"
        |""".stripMargin()
        if(dependenciesToml.exists())
            tomlString += dependenciesToml.text.replaceAll("\\s+\$", "")
        modsTomlOut.text = tomlString
    }
}
sourceSets.test.java.srcDirs(generateTestFiles.genJava)
sourceSets.test.resources.srcDirs(generateTestFiles.genResources)
compileTestJava.dependsOn(generateTestFiles)
compileTestKotlin.dependsOn(generateTestFiles)

//endregion
// ---------------------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------------------
//region // Shading

ext.shadePackages = { String... packages ->
    rootProject.shadePackages.addAll(packages)
}

def shadeOutput = file("$buildDir/shade/main")
// Gross, but ForgeGradle forces my hand by directly using `getResourcesDir()` and `getClassesDirs()` instead of
// using `getOutput()`, meaning I can't just do `output.dir(shadeOutput, builtBy: 'copyShadeClasses')`. I could
// use a separate sourceSet, however that comes with the baggage of a bunch of tasks, configurations, and source
// directories (which an IDE may conveniently create for you automatically)
// https://github.com/MinecraftForge/ForgeGradle/blob/ccf3035ba1f435f0f1a685a70d85df5481ee8b73/src/common/java/net/minecraftforge/gradle/common/util/runs/RunConfigGenerator.java#L128
// https://github.com/MinecraftForge/ForgeGradle/blob/ccf3035ba1f435f0f1a685a70d85df5481ee8b73/src/common/java/net/minecraftforge/gradle/common/util/runs/RunConfigGenerator.java#L138
((ConfigurableFileCollection)sourceSets.main.output.classesDirs).from(shadeOutput)

task copyShadeClasses(type: Sync) {
    dependsOn remapDependencies
    into shadeOutput
    from zipTree(remapDependencies.archivePath)
}
compileJava.finalizedBy(copyShadeClasses)
//endregion
// ---------------------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------------------
//region // Jars

def attributes = [
        "Implementation-Title": "LibrarianLib $human_name",
        "Implementation-Version": "$mod_version",
        "Implementation-Vendor": "Team Wizardry",
        "Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
        // Specify the IMixinConnector. This contains only the mixin files from this specific module.
        // https://github.com/SpongePowered/Mixin/wiki/Release-Notes---Mixin-0.8#toolchain-and-environment-changes
        "MixinConnector": "${project.name}.main.MixinConnector"
]

task sourcesJar(type: Jar) {
    dependsOn remapDependencySources, processResources
    classifier = 'sources'
    includeEmptyDirs = false
    manifest.attributes(attributes)
    from sourceSets.main.allSource
    from sourceSets.main.output.resourcesDir
    from zipTree(remapDependencySources.archivePath)
    exclude '**/*.class'
}

task deobfJar(type: Jar) {
    dependsOn classes, processResources, remapDependencies
    classifier = ''
    includeEmptyDirs = false
    manifest.attributes(attributes)

    from sourceSets.main.output
    from zipTree(remapDependencies.archivePath)
}

task obfJar(type: Jar) {
    dependsOn classes, processResources, remapDependencies
    classifier = 'obf'
    manifest.attributes(attributes)
    from zipTree(remapDependencies.archivePath)
}

jar {
    enabled = false
}

reobf {
    obfJar
}

assemble.dependsOn obfJar, deobfJar, sourcesJar

//// create a sources jar that includes this module and the shaded dependencies
//// Based largely on the gradle-preshadow-plugin: https://github.com/Abnaxos/gradle-preshadow-plugin/blob/07580f93f38818b15c411f6c47abea8cdfd0b2f9/src/main/groovy/ch/raffael/gradlePlugins/preshadow/Preshadow.groovy
//// has to be run in afterEvaluate since the relocator package list isn't ready until all the modules are configured
//afterEvaluate {
//    sourcesJar {
//        // collect the sources for all the shade dependencies
//        from configurations.detachedConfiguration(
//                configurations.shade.allDependencies.collect({ dep ->
//                    def sourceDep = dependencies.create(group: dep.group,
//                            name: dep.name,
//                            classifier: 'sources',
//                            version: dep.version)
//                    // apply any exclusions from the main dependency to the sources dependency
//                    if (dep instanceof ModuleDependency && sourceDep instanceof ModuleDependency) {
//                        def originalModule = (ModuleDependency) dep
//                        def sourceModule = (ModuleDependency) sourceDep
//
//                        originalModule.excludeRules.each {
//                            sourceModule.exclude group: it.group, module: it.module
//                        }
//                    }
//                    return sourceDep
//                }) as Dependency[]).collect { f ->
//            f.directory ? fileTree(f) : zipTree(f)
//        }
//        def stats = new ShadowStats()
//        // remap sources
//        eachFile { FileCopyDetails copyDetails ->
//            deobfJar.relocators.each { Relocator reloc ->
//                def pathContext = new RelocatePathContext(copyDetails.sourcePath, stats)
//                if (reloc.canRelocatePath(pathContext)) {
//                    copyDetails.path = reloc.relocatePath(pathContext)
//                }
//                if (!copyDetails.directory)
//                    copyDetails.filter { String line ->
//                        reloc.applyToSourceContent(line)
//                    }
//            }
//        }
//    }
//}

//endregion
// ---------------------------------------------------------------------------------------------------------------------

//endregion
// =====================================================================================================================
